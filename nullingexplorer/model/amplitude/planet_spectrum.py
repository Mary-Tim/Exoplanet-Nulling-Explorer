import torch
import torch.nn as nn

from .base_amplitude import BaseAmplitude
from nullingexplorer.model.spectrum import BinnedBlackBody
from nullingexplorer.model.transmission import DualChoppedDestructive, DualChoppedDifferential
from nullingexplorer.model.instrument import MiYinBasicType
from nullingexplorer.utils import Constants
from nullingexplorer.utils import Configuration as cfg

class PlanetBlackBody(BaseAmplitude):
    def __init__(self):
        super(PlanetBlackBody, self).__init__()
        # Surface Spectrum of the Planet
        self.spectrum = BinnedBlackBody()
        self.trans_map = DualChoppedDestructive()
        self.instrument = MiYinBasicType()
        # Constant parameters
        self.register_buffer('distance', cfg.get_property('distance') * Constants._pc_to_meter) # Distance between target and format (unit: pc)
        # Free parameters
        self.radius = nn.Parameter(torch.tensor(6371.) * 1.e3) # Planet radius (unit: kilometer)
        self.temperature = nn.Parameter(torch.tensor(273.))  # Temperature of planet (unit: Kelvin)
        self.ra  = nn.Parameter(torch.tensor(50.)) # Right ascension relatived to the star (unit: radian)
        self.dec = nn.Parameter(torch.tensor(50.)) # Declination relatived to the star (unit: radian)

    def forward(self, data):
        # return the number of photons generated by the planet
        return torch.pi * (self.radius / (self.distance))**2 * self.spectrum(self.temperature, data) * self.trans_map(self.ra, self.dec, data.wavelength, data) * self.instrument.field_of_view(self.ra, self.dec, data.wavelength)

        # TODO: Consider the field-of-view of instrument, using Sigmod?

class PlanetBlackBodyDiff(BaseAmplitude):
    def __init__(self):
        super(PlanetBlackBodyDiff, self).__init__()
        # Surface Spectrum of the Planet
        self.spectrum = BinnedBlackBody()
        self.trans_map = DualChoppedDifferential()
        self.instrument = MiYinBasicType()
        # Constant parameters
        self.register_buffer('distance', cfg.get_property('distance') * Constants._pc_to_meter) # Distance between target and format (unit: pc)
        # Free parameters
        self.radius = nn.Parameter(torch.tensor(6371.) * 1.e3) # Planet radius (unit: kilometer)
        self.temperature = nn.Parameter(torch.tensor(273.))  # Temperature of planet (unit: Kelvin)
        self.ra  = nn.Parameter(torch.tensor(50.)) # Right ascension relatived to the star (unit: radian)
        self.dec = nn.Parameter(torch.tensor(50.)) # Declination relatived to the star (unit: radian)

    def forward(self, data):
        # return the number of photons generated by the planet
        return torch.pi * (self.radius / (self.distance))**2 * self.spectrum(self.temperature, data) * self.trans_map(self.ra, self.dec, data.wavelength, data) * self.instrument.field_of_view(self.ra, self.dec, data.wavelength)

        # TODO: Consider the field-of-view of instrument, using Sigmod?