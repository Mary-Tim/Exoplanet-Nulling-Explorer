import torch
import torch.nn as nn

from .base_amplitude import BaseAmplitude
from nullingexplorer.utils import get_spectrum, get_transmission
from nullingexplorer.model.spectrum import BinnedBlackBody
from nullingexplorer.model.transmission import DualChoppedDestructive, DualChoppedDifferential, SingleBracewell
from nullingexplorer.model.instrument import MiYinBasicType
from nullingexplorer.utils import Constants as cons
from nullingexplorer.utils import Configuration as cfg

class PlanetBlackBody(BaseAmplitude):
    def __init__(self, spec='BinnedBlackBody'):
        super(PlanetBlackBody, self).__init__()
        # Surface Spectrum of the Planet
        #self.spectrum = BinnedBlackBody()
        self.spectrum = get_spectrum(spec)()
        #self.trans_map = SingleBracewell()
        self.trans_map = get_transmission(cfg.get_property('trans_map'))()
        self.instrument = MiYinBasicType()
        # Constant parameters
        self.register_buffer('distance', cfg.get_property('distance') * cons._pc_to_meter) # Distance between target and format (unit: pc)
        # Free parameters
        self.radius = nn.Parameter(torch.tensor(6371.) * 1.e3) # Planet radius (unit: kilometer)
        self.temperature = nn.Parameter(torch.tensor(273.))  # Temperature of planet (unit: Kelvin)
        self.ra  = nn.Parameter(torch.tensor(50.)) # Right ascension relative to the star (unit: radian)
        self.dec = nn.Parameter(torch.tensor(50.)) # Declination relative to the star (unit: radian)

        # Boundary of parameters
        self.register_buffer('bound_radius', torch.tensor([1.e5, 1.e7]))
        self.register_buffer('bound_temperature', torch.tensor([100., 800.]))
        self.register_buffer('bound_ra', torch.tensor([-torch.pi, torch.pi]))
        self.register_buffer('bound_dec', torch.tensor([-torch.pi, torch.pi]))

    def forward(self, data):
        # return the number of photons generated by the planet
        return torch.pi * (self.radius / (self.distance))**2 * self.spectrum(self.temperature, data) * \
            self.trans_map(self.ra / cons._radian_to_mas, self.dec / cons._radian_to_mas, data['wl_mid'], data) * self.instrument.field_of_view(self.ra / cons._radian_to_mas, self.dec / cons._radian_to_mas, data['wl_mid'])

class RelativePlanetBlackBody(BaseAmplitude):
    def __init__(self, spec='BinnedBlackBody'):
        super(RelativePlanetBlackBody, self).__init__()
        # Surface Spectrum of the Planet
        self.spectrum = get_spectrum(spec)()
        self.trans_map = get_transmission(cfg.get_property('trans_map'))()
        self.instrument = MiYinBasicType()
        # Constant parameters
        self.register_buffer('distance', cfg.get_property('distance') * cons._pc_to_meter) # Distance between target and format (unit: pc)
        self.register_buffer('e_rad', torch.tensor(6371.) * 1e3) # Earth radius (unit: kilometer)
        self.register_buffer('e_temp', torch.tensor(285.)) # Earth temperature (unit: Kelvin)
        self.register_buffer('e_mas', torch.tensor(100.) / cons._radian_to_mas) # Earth-Sun angular separation at 10 pc (unit: mas)

        # Free parameters
        self.r_radius = nn.Parameter(torch.tensor(1.)) # Relative planet radius (unit: dimensionless)
        self.r_temperature = nn.Parameter(torch.tensor(1.))  # Relative temperature of planet (unit: dimensionless)
        self.r_ra  = nn.Parameter(torch.tensor(1.)) # Relative right ascension relative to the star (unit: dimensionless)
        self.r_dec = nn.Parameter(torch.tensor(1.)) # Relative declination relative to the star (unit: dimensionless)

        # Boundary of parameters
        self.boundary = {
            'r_radius': torch.tensor([0., 5.]),
            'r_temperature': torch.tensor([0., 5.]),
            'r_ra': torch.tensor([-10., 10.]),
            'r_dec': torch.tensor([-10., 10.]),
        }

    def forward(self, data):
        # return the number of photons generated by the planet
        return torch.pi * (self.r_radius * self.e_rad / (self.distance))**2 * self.spectrum(self.r_temperature * self.e_temp, data) * \
            self.trans_map(self.r_ra * self.e_mas, self.r_dec * self.e_mas, data['wl_mid'], data) * self.instrument.field_of_view(self.r_ra * self.e_mas, self.r_dec * self.e_mas, data['wl_mid'])

class RelativePolarPlanetBlackBody(BaseAmplitude):
    def __init__(self, spec='BinnedBlackBody'):
        super(RelativePolarPlanetBlackBody, self).__init__()
        # Surface Spectrum of the Planet
        self.spectrum = get_spectrum(spec)()
        self.trans_map = get_transmission(cfg.get_property('trans_map'))()
        self.instrument = MiYinBasicType()
        # Constant parameters
        self.register_buffer('distance', cfg.get_property('distance') * cons._pc_to_meter) # Distance between target and format (unit: pc)
        self.register_buffer('e_rad', torch.tensor(6371.) * 1e3) # Earth radius (unit: kilometer)
        self.register_buffer('e_temp', torch.tensor(285.)) # Earth temperature (unit: Kelvin)
        self.register_buffer('e_mas', torch.tensor(100.) / cons._radian_to_mas) # Earth-Sun angular separation at 10 pc (unit: mas)

        # Free parameters
        self.r_radius = nn.Parameter(torch.tensor(1.)) # Relative planet radius (unit: dimensionless)
        self.r_temperature = nn.Parameter(torch.tensor(1.))  # Relative temperature of planet (unit: dimensionless)
        self.r_angular  = nn.Parameter(torch.tensor(1.)) # Relative angular separation relative to the star (unit: dimensionless)
        self.r_polar    = nn.Parameter(torch.tensor(1.)) # Relative declination relative to the star (unit: dimensionless)

        # Boundary of parameters
        self.boundary = {
            'r_radius': torch.tensor([0., 5.]),
            'r_temperature': torch.tensor([0., 5.]),
            'r_angular': torch.tensor([0.1, 5.]),
            'r_polar': torch.tensor([0., 2*torch.pi]),
        }

    def forward(self, data):
        # return the number of photons generated by the planet
        return torch.pi * (self.r_radius * self.e_rad / (self.distance))**2 * self.spectrum(self.r_temperature * self.e_temp, data) * \
            self.trans_map(self.r_angular * self.e_mas, self.r_polar, data['wl_mid'], data) * self.instrument.field_of_view_polar(self.r_angular * self.e_mas, data['wl_mid'])