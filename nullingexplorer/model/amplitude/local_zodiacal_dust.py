import torch
import torch.nn as nn
from torchquad import Boole, MonteCarlo, Trapezoid

from .base_amplitude import BaseAmplitude
from nullingexplorer.model.spectrum import TorchQuadBlackBody, InterpBlackBody
from nullingexplorer.model.instrument import MiYinBasicType
from nullingexplorer.utils import Constants, get_transmission
from nullingexplorer.utils import Configuration as cfg

class LocalZodiacalDust(BaseAmplitude):
    '''
    The photon emission by local-zodiacal dust
    Reference to LIFE-II (doi:10.1051/0004-6361/202141958)
    '''
    def __init__(self):
        super(LocalZodiacalDust, self).__init__()
        # Register models
        self.spectrum = TorchQuadBlackBody()
        #self.trans_map = SingleBracewell()
        self.trans_map = get_transmission(cfg.get_property('trans_map'))()
        self.instrument = MiYinBasicType()
        # Constant parameters
        self.register_buffer('target_lon'   , cfg.get_property('target_longitude')     / Constants._radian_to_degree)
        self.register_buffer('target_lat'    , cfg.get_property('target_latitude')      / Constants._radian_to_degree)
        self.register_buffer('formation_lon', cfg.get_property('formation_longitude')  / Constants._radian_to_degree)
        self.register_buffer('mirror_diameter', cfg.get_property('mirror_diameter'))      # Diameter of each mirror (unit: meter)

        self.register_buffer('relative_lon', torch.pi - (self.target_lon - self.formation_lon))
        self.register_buffer('sun_radius_au', torch.tensor(6.955e8/Constants._au_to_meter))
        self.register_buffer('formation_location_au', torch.tensor(1.5))
        self.register_buffer('sun_temperature', torch.tensor(5772.))
        self.register_buffer('effective_temperature', torch.tensor(265.))
        self.register_buffer('optical_depth', torch.tensor(4.e-8))
        self.register_buffer('dust_albedo', torch.tensor(0.22))

        # Calculate exo-zodi
        self.register_buffer('local_zodi', torch.tensor([], dtype=torch.float64))  

    def init_local_zodi(self, data) -> torch.Tensor:
        dust_emission   = self.spectrum(self.effective_temperature, data)
        dust_reflection = self.dust_albedo * self.spectrum(self.sun_temperature, data) * (self.sun_radius_au / self.formation_location_au)**2
        fov_area = torch.pi * (0.5*data['wl_mid']/self.mirror_diameter)**2
        self.local_zodi.data = self.optical_depth * (dust_emission + dust_reflection) \
                                * torch.sqrt(torch.pi / torch.arccos(torch.cos(self.relative_lon) * torch.cos(self.target_lat))\
                                             / (torch.sin(self.target_lat)**2 + 0.36 * (data['wl_mid']/11e-6)**(-0.8)*torch.cos(self.target_lat)**2)) * fov_area
        integrator = Boole()
        integrate_jit_compiled_parts = integrator.get_jit_compiled_integrate(
            dim=3, N=300000, backend="torch"
        )
        trans_factor = torch.zeros(len(data))
        for i, point in enumerate(data):
            theta_hi = 0.5 * point['wl_hi'] / self.mirror_diameter
            intg_trans_map = lambda x: self.trans_map(x[:,0], x[:,1], x[:,2], point) * self.instrument.field_of_view(x[:,0], x[:,1], x[:,2])
            trans_factor[i] = integrate_jit_compiled_parts(intg_trans_map, torch.tensor([[-theta_hi, theta_hi], [-theta_hi, theta_hi], [point['wl_lo'], point['wl_hi']]])) / (2*theta_hi)**2 / (point['wl_hi'] - point['wl_lo'])
        self.local_zodi = self.local_zodi * trans_factor

    def forward(self, data):
        # return the number of photons generated by the planet
        if len(self.local_zodi) == 0:
            self.init_local_zodi(data)

        return self.local_zodi

class LocalZodiacalDustMatrix(LocalZodiacalDust):
    def __init__(self):
        super().__init__()
        self.spectrum = InterpBlackBody()
        self.register_buffer('vol_number', torch.tensor(500, dtype=int))  

    def init_local_zodi(self, data) -> torch.Tensor:
        dust_emission   = self.spectrum(self.effective_temperature, data)
        dust_reflection = self.dust_albedo * self.spectrum(self.sun_temperature, data) * (self.sun_radius_au / self.formation_location_au)**2
        fov_area = torch.pi * (0.5*data['wl_mid']/self.mirror_diameter)**2
        self.local_zodi.data = self.optical_depth * (dust_emission + dust_reflection) \
                                * torch.sqrt(torch.pi / torch.arccos(torch.cos(self.relative_lon) * torch.cos(self.target_lat))\
                                             / (torch.sin(self.target_lat)**2 + 0.36 * (data['wl_mid']/11e-6)**(-0.8)*torch.cos(self.target_lat)**2)) * fov_area

        def trans_map_scale(point):
            theta_hi = 0.5 * point['wl_hi'] / self.mirror_diameter
            ra_interp = torch.linspace(-theta_hi, theta_hi, self.vol_number)
            d_ra = torch.abs(ra_interp[1] - ra_interp[0])
            ra_mesh, dec_mesh = torch.meshgrid(ra_interp, ra_interp, indexing='ij')
            ra_mesh = ra_mesh.flatten()
            dec_mesh = dec_mesh.flatten()
            intg_trans_map = lambda ra, dec: self.trans_map(ra, dec, point['wl_mid'], point) * self.instrument.field_of_view(ra, dec, point['wl_mid'])
            return torch.sum(torch.vmap(intg_trans_map)(ra_mesh, dec_mesh)) / len(ra_mesh)
        
        trans_factor = torch.zeros(len(data))
        chunk_size = 10
        for i in range(0, len(data), chunk_size):
            if i+chunk_size > len(data):
                trans_factor[i:] = torch.vmap(trans_map_scale)(data[i:])
            trans_factor[i:i+chunk_size] = torch.vmap(trans_map_scale)(data[i:i+chunk_size])
        self.local_zodi = self.local_zodi * trans_factor

class LocalZodiacalDustConstant(LocalZodiacalDust):
    def __init__(self):
        super().__init__()
        self.spectrum = InterpBlackBody()
        self.register_buffer('vol_number', torch.tensor(500, dtype=int))  

    def init_local_zodi(self, data) -> torch.Tensor:
        dust_emission   = self.spectrum(self.effective_temperature, data)
        dust_reflection = self.dust_albedo * self.spectrum(self.sun_temperature, data) * (self.sun_radius_au / self.formation_location_au)**2
        fov_area = torch.pi * (0.5*data['wl_mid']/self.mirror_diameter)**2
        self.local_zodi.data = self.optical_depth * (dust_emission + dust_reflection) \
                                * torch.sqrt(torch.pi / torch.arccos(torch.cos(self.relative_lon) * torch.cos(self.target_lat))\
                                             / (torch.sin(self.target_lat)**2 + 0.36 * (data['wl_mid']/11e-6)**(-0.8)*torch.cos(self.target_lat)**2)) * fov_area

        def trans_map_scale(point):
            theta_hi = 0.5 * point['wl_hi'] / self.mirror_diameter
            ra_interp = torch.linspace(-theta_hi, theta_hi, self.vol_number)
            d_ra = torch.abs(ra_interp[1] - ra_interp[0])
            ra_mesh, dec_mesh = torch.meshgrid(ra_interp, ra_interp, indexing='ij')
            ra_mesh = ra_mesh.flatten()
            dec_mesh = dec_mesh.flatten()
            intg_trans_map = lambda ra, dec: self.trans_map(ra, dec, point['wl_mid'], point) * self.instrument.field_of_view(ra, dec, point['wl_mid'])
            return torch.sum(torch.vmap(intg_trans_map)(ra_mesh, dec_mesh)) / len(ra_mesh)
        
        chunk_size = 10
        data_0 = data[data['phase']==data['phase'][0]]
        trans_factor = torch.zeros(len(data_0))
        for i in range(0, len(data_0), chunk_size):
            if i+chunk_size > len(data_0):
                trans_factor[i:] = torch.vmap(trans_map_scale)(data_0[i:])
            trans_factor[i:i+chunk_size] = torch.vmap(trans_map_scale)(data_0[i:i+chunk_size])
        phase_num = len(torch.unique(data['phase']))
        self.local_zodi = self.local_zodi * trans_factor.repeat(phase_num)