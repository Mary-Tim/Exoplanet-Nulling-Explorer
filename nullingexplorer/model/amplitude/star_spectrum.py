import torch
import torch.nn as nn
from torchquad import Boole

from .base_amplitude import BaseAmplitude
from nullingexplorer.model.spectrum import BlackBody
from nullingexplorer.model.transmission import DualChoppedDestructive, SingleBracewell
from nullingexplorer.utils import Constants, get_transmission
from nullingexplorer.utils import Configuration as cfg

class StarBlackBody(BaseAmplitude):
    def __init__(self):
        super(StarBlackBody, self).__init__()
        # Surface Spectrum of the Planet
        self.spectrum = BlackBody()
        #self.trans_map = SingleBracewell()
        #self.trans_map = DualChoppedDestructive()
        self.trans_map = get_transmission(cfg.get_property('trans_map'))()
        # Constant parameters
        self.register_buffer('distance', cfg.get_property('distance') * Constants._pc_to_meter) # Distance between target and format (unit: pc)
        self.register_buffer('radius', cfg.get_property('star_radius') * 1e3) # Star radius (unit: kilometer)
        self.register_buffer('temperature', cfg.get_property('star_temperature')) # Star radius (unit: kilometer)
        # Calculate stellar leak
        self.register_buffer('star_light', torch.tensor([], dtype=torch.float64))  

    def init_star_light(self, data) -> torch.Tensor:
        integrator = Boole()
        integrate_jit_compiled_parts = integrator.get_jit_compiled_integrate(
            dim=3, N=10000, backend="torch"
        )

        wl_quad_domains = torch.stack((data['wl_lo'], data['wl_hi'])).t()

        list_star_light = []
        for point, domain in zip(data, wl_quad_domains):
            def star_light(x):
                ra, dec = self.trans_map.to_cartesian(x[:,0] / self.distance, x[:,1])
                return self.spectrum(self.temperature, x[:,2]) * self.trans_map(ra, dec, x[:,2], point) * x[:,0]
            list_star_light.append(integrate_jit_compiled_parts(star_light, torch.tensor([[0., self.radius], [-torch.pi, torch.pi], domain])))

        self.star_light.data = torch.stack(list_star_light) / self.distance**2

    def forward(self, data):
        # return the number of photons generated by the planet
        if len(self.star_light) == 0:
            self.init_star_light(data)

        return self.star_light

        # TODO: Consider the field-of-view of instrument, using Sigmod?

    def star_luminosity(self):
        return torch.tensor(self.radius**2 * (self.temperature / 5780.)**4)


class StarBlackBodyMatrix(StarBlackBody):

    def __init__(self):
        super().__init__()
        self.register_buffer('vol_number', torch.tensor(200, dtype=int))  
        self.register_buffer('wl_number', torch.tensor(5, dtype=int))  

    def init_star_light(self, data) -> torch.Tensor:

        radius_interp = torch.linspace(0., self.radius, self.vol_number)
        psi_interp = torch.linspace(-torch.pi, torch.pi, self.vol_number)
        d_radius = (radius_interp[1] - radius_interp[0]) 
        d_psi = torch.abs(psi_interp[1] - psi_interp[0])

        r_mesh, psi_mesh = torch.meshgrid(radius_interp, psi_interp, indexing='ij')
        r_mesh = r_mesh.flatten()
        psi_mesh = psi_mesh.flatten()

        def star_light(point):
            wl_interp = torch.linspace(point['wl_lo'], point['wl_hi'], self.wl_number)
            delta_wl = (point['wl_hi'] - point['wl_lo']) / self.wl_number
            def infin_star(radius, psi):
                theta = radius / self.distance
                ra, dec = self.trans_map.to_cartesian(theta, psi)
                interp_volume = d_psi / 2. * d_radius * (d_radius + 2*radius) * delta_wl
                return torch.sum(self.spectrum(self.temperature, wl_interp) * self.trans_map(ra, dec, wl_interp, point) * interp_volume)

            return torch.sum(torch.vmap(infin_star)(r_mesh, psi_mesh))

        #list_star_light = torch.vmap(star_light, chunk_size=10)(data)
        list_star_light = torch.zeros(len(data))
        chunk_size = 10
        for i in range(0, len(data), chunk_size):
            if i+chunk_size > len(data):
                list_star_light[i:] = torch.vmap(star_light)(data[i:])
            list_star_light[i:i+chunk_size] = torch.vmap(star_light)(data[i:i+chunk_size])

        self.star_light.data = list_star_light / self.distance**2